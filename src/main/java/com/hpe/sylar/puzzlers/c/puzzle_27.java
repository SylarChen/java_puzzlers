package com.hpe.sylar.puzzlers.c;

public class puzzle_27 {
    public static void main(String[] args) {
        //输出是什么？
        int i = 0;
        while (-1 << i != 0)
            i++;
        System.out.println(i);

//        常量-1 是所有 32 位都被置位的 int 数值（0xffffffff）。左移操作符将 0 移入
//        到由移位所空出的右边的最低位，因此表达式（-1 << i）将 i 最右边的位设置
//        为 0，并保持其余的 32 - i 位为 1。很明显，这个循环将完成 32 次迭代，因为
//                -1 << i 对任何小于 32 的 i 来说都不等于 0。你可能期望终止条件测试在 i 等于
//        32 时返回 false，从而使程序打印 32，但是它打印的并不是 32。实际上，它不
//        会打印任何东西，而是进入了一个无限循环。
//        问题在于（-1 << 32）等于-1 而不是 0

//        http://blog.csdn.net/yangfeitarena/article/details/4358794
//        如果对一个int 型，进行移位，x << y; 当y小于32时，移位后的结果一般都在我们的预料当中；
//        而如果y大于32时，由于移位超出了int所能表示的范围，这时就先把y化成二进制数，然后取该二进制数右端的低5位，再把这5位化成十进制，此时的这个十进制就是要对X移动的位数。
//
//        例如：
//        int int a=140;
//        a << 34;
//        System.out.println(Integer.toBinaryString(a << b));
//
//        上面那两个语句的执行过程是：先把a化成二进制数：10001100
//        执行语句 a << 34   对a左移32位时，先把 34化成二进制：100010，对该二进制数取右边5位，即00010，化成十进制数为2，所以实际上是对a左移两位。
    }
}
