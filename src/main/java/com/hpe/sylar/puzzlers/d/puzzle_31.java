package com.hpe.sylar.puzzlers.d;

public class puzzle_31 {
    public static void main(String[] args) {
//        请提供一个对 i 的声明，将下面的循环转变为一个无限循环：
        while (i != 0) {
            i >>>= 1;
        }

//        java移位运算符：<<（左移）、>>（带符号右移）和>>>（无符号右移）
//        http://blog.sina.com.cn/s/blog_99201d890101hd6s.html

//        解决本谜题的关键在于>>>=是一个复合赋值操作符。（复合赋值操作符包括*=、/=、%=、+=、-=、<<=、>>=、>>>=、
//        &=、^=和|=。）有关混合操作符的一个不幸的事实是，它们可能会自动地执行窄
//        化原始类型转换，这种转换把一种数字类型转换成了另一种更缺乏表示能力的类型

//        答案：
//        short i = -1;

//        在执行移位操作时，第一步是将 i 提升为 int 类型。所有算数操作都会对 short、byte
//        和 char 类型的操作数执行这样的提升。这种提升是一个拓宽原始类型转换，因
//        此没有任何信息会丢失。这种提升执行的是符号扩展，因此所产生的 int 数值是
//        0xffffffff。然后，这个数值右移 1 位，但不使用符号扩展，因此产生了 int
//        数值 0x7fffffff。最后，这个数值被存回到 i 中。为了将 int 数值存入 short
//        变量，Java 执行的是可怕的窄化原始类型转换，它直接将高 16 位截掉。这样就
//        只剩下(short)oxffff 了，我们又回到了开始处。循环的第二次以及后续的迭代
//        行为都是一样的，因此循环将永远不会终止。
    }
}
